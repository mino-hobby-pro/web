<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3D Shooter vs CPU - Maze & Open Field Plus</title>
  <style>
    body { margin: 0; overflow: hidden; }
    /* タイトルオーバーレイ */
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-family: sans-serif;
      z-index: 2;
    }
    /* ゲームオーバー表示 */
    #game-over {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #ff5555;
      font-family: sans-serif;
      font-size: 50px;
      z-index: 3;
      visibility: hidden;
    }
    /* ミニマップ：画面左上に固定 */
    #minimap {
      position: absolute;
      top: 10px;
      left: 10px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.5);
      z-index: 4;
    }
  </style>
</head>
<body>
  <!-- タイトルオーバーレイ -->
  <div id="overlay">
    <h1>3D Shooter vs CPU</h1>
    <p>【操作方法】</p>
    <p>W　：前進　S　：後退</p>
    <p>A　：左回転　D　：右回転</p>
    <p>マウス照準＋Space：射撃（無制限・即発射）</p>
    <p>Enter：ゲーム開始</p>
  </div>
  <!-- ゲームオーバー表示 -->
  <div id="game-over">
    <h1>GAME OVER</h1>
    <p>ページを再読み込みして再挑戦してください！</p>
  </div>
  <!-- ミニマップ用キャンバス -->
  <canvas id="minimap" width="300" height="300"></canvas>

  <!-- Three.js CDN (r128) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /***********************
     * グローバル変数・定数
     ***********************/
    let scene, camera, renderer, clock;
    let floorMesh; // 地面（レイキャスター対象）
    let obstacles = []; // 平原内の障害物＋迷路の壁
    let bullets = [];   // プレイヤー弾
    let enemyBullets = []; // 敵の弾
    let enemies = [];   // 複数のCPU（敵）
    let lastShootTime = 0;
    // リロード待ちは 0（無制限・即発射）
    const shootCooldown = 0;
    const terrainSize = 500; // 平原全体のサイズ
    // ミニマップ
    let minimap, minimapCtx;
    // キー状態
    let keys = {};
    // マウス位置（正規化デバイス座標）
    let mouse = new THREE.Vector2();

    /***********************
     * 初期化処理
     ***********************/
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
      // プレイヤーは平原の左下付近に配置
      camera.position.set(-terrainSize/2 + 25, 5, -terrainSize/2 + 25);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      clock = new THREE.Clock();

      // ミニマップキャンバスの取得
      minimap = document.getElementById('minimap');
      minimapCtx = minimap.getContext('2d');

      // ライティング
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 50);
      scene.add(directionalLight);

      // 平原（地面）の作成
      const floorGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize);
      const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x777777 });
      floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
      floorMesh.rotation.x = -Math.PI/2;
      scene.add(floorMesh);

      // オープンフィールドの障害物生成
      createObstacles();

      // 迷路エリア生成（たとえば、平原の左上領域に幅250×深さ250の迷路）
      createMazeArea();

      // CPU（敵）の生成（複数配置）
      createEnemies(5); // ここでは 5体、必要に応じて数を変更

      // 各種イベントリスナー登録
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      window.addEventListener('keydown', onShoot);
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('resize', onWindowResize, false);

      animate();
    }

    /***********************
     * オープンフィールドの障害物生成
     ***********************/
    function createObstacles() {
      const numObstacles = 10;
      for (let i = 0; i < numObstacles; i++) {
        let width = Math.random() * 30 + 20;
        let depth = Math.random() * 30 + 20;
        let height = Math.random() * 20 + 10;
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshPhongMaterial({ color: 0x555555 });
        let obstacle = new THREE.Mesh(geometry, material);
        obstacle.userData.width = width;
        obstacle.userData.depth = depth;
        // 障害物は平原内（境界から余裕を持って配置）
        const margin = 50;
        obstacle.position.x = Math.random() * (terrainSize - 2 * margin) - (terrainSize / 2 - margin);
        obstacle.position.z = Math.random() * (terrainSize - 2 * margin) - (terrainSize / 2 - margin);
        obstacle.position.y = height / 2;
        obstacles.push(obstacle);
        scene.add(obstacle);
      }
    }

    /***********************
     * 迷路エリア生成
     *  平原の左上領域 (x: -terrainSize/2 ～ 0, z: 0 ～ terrainSize/2) に幅250×深さ250の迷路を作成
     *  ここで、下端中央（mazeGrid[rows-1][Math.floor(cols/2)]）を必ず通路（入口）にします。
     ***********************/
    function createMazeArea() {
      const mazeRegionWidth = terrainSize / 2;  // 250
      const mazeRegionDepth = terrainSize / 2;    // 250
      // 迷路を配置する領域の左上オフセット
      const mazeOffsetX = -terrainSize / 2;
      const mazeOffsetZ = 0;
      const cellSize = 10;
      const cols = Math.floor(mazeRegionWidth / cellSize); // 25
      const rows = Math.floor(mazeRegionDepth / cellSize);   // 25

      let mazeGrid = generateMazeGrid(cols, rows);
      // 迷路下端中央に「入口」を作成
      mazeGrid[rows - 1][Math.floor(cols / 2)] = 0;

      // グリッドに従い壁（セル値 1 の部分）を配置
      for (let j = 0; j < rows; j++) {
        for (let i = 0; i < cols; i++) {
          if (mazeGrid[j][i] === 1) {
            const geometry = new THREE.BoxGeometry(cellSize, 10, cellSize);
            const material = new THREE.MeshPhongMaterial({ color: 0x333333 });
            let wall = new THREE.Mesh(geometry, material);
            wall.position.x = mazeOffsetX + i * cellSize + cellSize / 2;
            wall.position.y = 5;
            wall.position.z = mazeOffsetZ + j * cellSize + cellSize / 2;
            wall.userData.width = cellSize;
            wall.userData.depth = cellSize;
            obstacles.push(wall);
            scene.add(wall);
          }
        }
      }
    }

    /***********************
     * 迷路グリッド生成（再帰的バックトラッキング）
     ***********************/
    function generateMazeGrid(cols, rows) {
      // すべてのセルを1（壁）で初期化
      let grid = [];
      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          grid[y][x] = 1;
        }
      }
      // 配列シャッフル
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          let j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      // 再帰的に通路を掘る関数
      function carve(x, y) {
        grid[y][x] = 0;
        let directions = [[2,0], [-2,0], [0,2], [0,-2]];
        shuffle(directions);
        for (let d of directions) {
          let nx = x + d[0], ny = y + d[1];
          if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
            if (grid[ny][nx] === 1) {
              grid[y + d[1] / 2][x + d[0] / 2] = 0;
              carve(nx, ny);
            }
          }
        }
      }
      carve(1,1);
      return grid;
    }

    /***********************
     * CPU（敵）生成
     *  複数（引数 count で指定）作成し、各自大きな巡回ルートを持たせる
     ***********************/
    function createEnemies(count) {
      // 共通の巡回ルート（8点ルート）
      const patrolPoints = [
        new THREE.Vector3( terrainSize/2 - 10, 0, terrainSize/2 - 10),
        new THREE.Vector3( terrainSize/2 - 10, 0, terrainSize/2/2),
        new THREE.Vector3( terrainSize/2 - 10, 0, -terrainSize/2 + 10),
        new THREE.Vector3( 0, 0, -terrainSize/2 + 10),
        new THREE.Vector3( -terrainSize/2 + 10, 0, -terrainSize/2 + 10),
        new THREE.Vector3( -terrainSize/2 + 10, 0, 0),
        new THREE.Vector3( -terrainSize/2 + 10, 0, terrainSize/2 - 10),
        new THREE.Vector3( 0, 0, terrainSize/2 - 10)
      ];
      for (let i = 0; i < count; i++) {
        let enemy = new THREE.Group();
        // ボディ
        const bodyGeo = new THREE.BoxGeometry(1.5, 3, 1);
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.position.y = 1.5;
        // ヘッド
        const headGeo = new THREE.SphereGeometry(0.75, 16, 16);
        const headMat = new THREE.MeshPhongMaterial({ color: 0xff8888 });
        const headMesh = new THREE.Mesh(headGeo, headMat);
        headMesh.position.y = 3.0;
        enemy.add(bodyMesh);
        enemy.add(headMesh);
        enemy.userData.velocity = new THREE.Vector3(0,0,0);
        enemy.userData.patrolPoints = patrolPoints;
        // ランダムな巡回開始位置
        enemy.userData.patrolIndex = Math.floor(Math.random() * patrolPoints.length);
        enemy.position.copy(enemy.userData.patrolPoints[ enemy.userData.patrolIndex ]);
        enemy.userData.state = "patrol";  // "patrol" または "chase"
        enemy.userData.shootTimer = 0;
        enemies.push(enemy);
        scene.add(enemy);
      }
    }

    /***********************
     * イベントハンドラ
     ***********************/
    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onKeyDown(e) {
      keys[e.code] = true;
      if (document.getElementById('overlay').style.display !== 'none' && e.code === 'Enter') {
        document.getElementById('overlay').style.display = 'none';
      }
    }
    function onKeyUp(e) {
      keys[e.code] = false;
    }
    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }
    function onShoot(e) {
      if (!playerAlive) return;
      if (e.code === 'Space') {
        const currentTime = clock.getElapsedTime();
        if (currentTime - lastShootTime > shootCooldown) {
          shootBullet();
          lastShootTime = currentTime;
        }
      }
    }
    
    /***********************
     * プレイヤー弾生成（マウス照準方向へ）
     ***********************/
    function shootBullet() {
      const bulletGeo = new THREE.SphereGeometry(0.3, 8, 8);
      const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      let bullet = new THREE.Mesh(bulletGeo, bulletMat);
      bullet.position.copy(camera.position);
      // マウス位置からレイキャスターで地面との交点を求める
      let raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      let intersects = raycaster.intersectObject(floorMesh);
      if (intersects.length > 0) {
        let point = intersects[0].point;
        let direction = point.clone().sub(camera.position).normalize();
        bullet.userData = { velocity: direction.multiplyScalar(50) };
        scene.add(bullet);
        bullets.push(bullet);
      }
    }

    /***********************
     * 衝突判定
     *  平原境界および obstacles 配列に登録されたオブジェクトとの簡易 AABB 判定
     ***********************/
    function isColliding(pos, radius) {
      let half = terrainSize / 2;
      if (pos.x - radius < -half || pos.x + radius > half ||
          pos.z - radius < -half || pos.z + radius > half)
          return true;
      for (let i = 0; i < obstacles.length; i++) {
        let obs = obstacles[i];
        let halfW = obs.userData.width / 2;
        let halfD = obs.userData.depth / 2;
        if (Math.abs(pos.x - obs.position.x) < halfW + radius &&
            Math.abs(pos.z - obs.position.z) < halfD + radius)
          return true;
      }
      return false;
    }

    /***********************
     * 弾の更新処理（プレイヤー弾・敵弾）
     ***********************/
    function updateBullets(delta) {
      // プレイヤー弾
      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
        if (Math.abs(b.position.x) > terrainSize/2 || Math.abs(b.position.z) > terrainSize/2) {
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        if (isColliding(b.position, 0.3)) {
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        // 各敵との衝突判定（距離2未満ならヒット）
        for (let j = enemies.length - 1; j >= 0; j--) {
          let enemy = enemies[j];
          if (b.position.distanceTo(enemy.position) < 2) {
            // 敵を除去
            scene.remove(enemy);
            enemies.splice(j, 1);
            scene.remove(b);
            bullets.splice(i, 1);
            break;
          }
        }
      }
      // 敵弾
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        let b = enemyBullets[i];
        b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
        if (Math.abs(b.position.x) > terrainSize/2 || Math.abs(b.position.z) > terrainSize/2) {
          scene.remove(b);
          enemyBullets.splice(i, 1);
          continue;
        }
        if (isColliding(b.position, 0.3)) {
          scene.remove(b);
          enemyBullets.splice(i, 1);
          continue;
        }
        if (b.position.distanceTo(camera.position) < 1.5) {
          playerAlive = false;
          scene.remove(b);
          enemyBullets.splice(i, 1);
          showGameOver();
          break;
        }
      }
    }

    /***********************
     * 敵（CPU）更新処理（複数）
     ***********************/
    function updateEnemies(delta) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        let enemy = enemies[i];
        // プレイヤーとの水平距離
        let distanceToPlayer = camera.position.clone().sub(enemy.position).length();
        const chaseDistance = 80;
        if (distanceToPlayer < chaseDistance) {
          enemy.userData.state = "chase";
        } else {
          enemy.userData.state = "patrol";
        }
        // 目標地点
        let target;
        if (enemy.userData.state === "chase") {
          target = camera.position;
        } else {
          target = enemy.userData.patrolPoints[enemy.userData.patrolIndex];
          if (enemy.position.distanceTo(target) < 5) {
            enemy.userData.patrolIndex = (enemy.userData.patrolIndex + 1) % enemy.userData.patrolPoints.length;
            target = enemy.userData.patrolPoints[enemy.userData.patrolIndex];
          }
        }
        // 目標方向の単位ベクトル
        let desired = new THREE.Vector3();
        desired.subVectors(target, enemy.position);
        desired.y = 0;
        let dist = desired.length();
        if (dist < 0.1) dist = 0.1;
        desired.normalize();
        // パラメータ：最大速度・加速度
        const enemyMaxSpeed = 8;
        const enemyAcceleration = 20;
        let desiredVelocity = desired.clone().multiplyScalar(enemyMaxSpeed);
        let currentVelocity = enemy.userData.velocity;
        let deltaV = desiredVelocity.clone().sub(currentVelocity);
        let maxDelta = enemyAcceleration * delta;
        if (deltaV.length() > maxDelta) { deltaV.setLength(maxDelta); }
        currentVelocity.add(deltaV);
        // 衝突チェック付きで移動
        let tentativePos = enemy.position.clone().add(currentVelocity.clone().multiplyScalar(delta));
        if (!isColliding(tentativePos, 1)) {
          enemy.position.copy(tentativePos);
        } else {
          let adjusted = false;
          const angles = [0.3, -0.3, 0.6, -0.6];
          for (let angle of angles) {
            let testDir = desired.clone().applyAxisAngle(new THREE.Vector3(0,1,0), angle);
            let testVelocity = testDir.clone().multiplyScalar(enemyMaxSpeed);
            let testPos = enemy.position.clone().add(testVelocity.clone().multiplyScalar(delta));
            if (!isColliding(testPos, 1)) {
              enemy.userData.velocity.copy(testVelocity);
              enemy.position.copy(testPos);
              adjusted = true;
              break;
            }
          }
          if (!adjusted) {
            enemy.userData.velocity.multiplyScalar(0.5);
          }
        }
        // 向き調整（移動方向に合わせる）
        if (enemy.userData.velocity.length() > 0.1) {
          enemy.rotation.y = Math.atan2(enemy.userData.velocity.x, enemy.userData.velocity.z);
        }
        // 追尾中は一定間隔で射撃
        if (enemy.userData.state === "chase") {
          enemy.userData.shootTimer += delta;
          if (enemy.userData.shootTimer > 2) {
            enemyShootSingle(enemy);
            enemy.userData.shootTimer = 0;
          }
        } else {
          enemy.userData.shootTimer = 0;
        }
      }
    }
    
    /***********************
     * 敵単体の射撃処理（プレイヤー方向へ）
     ***********************/
    function enemyShootSingle(enemy) {
      const bulletGeo = new THREE.SphereGeometry(0.3, 8, 8);
      const bulletMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      let bullet = new THREE.Mesh(bulletGeo, bulletMat);
      bullet.position.copy(enemy.position);
      let direction = new THREE.Vector3();
      direction.subVectors(camera.position, enemy.position).normalize();
      bullet.userData = { velocity: direction.multiplyScalar(30) };
      scene.add(bullet);
      enemyBullets.push(bullet);
    }

    /***********************
     * ゲームオーバー表示
     ***********************/
    function showGameOver() {
      document.getElementById('game-over').style.visibility = "visible";
    }

    /***********************
     * プレイヤー更新（W/S 移動、A/D 回転）
     ***********************/
    function updatePlayer(delta) {
      if (!playerAlive) return;
      const moveSpeed = 20;
      const rotationSpeed = Math.PI;
      if (keys['KeyA']) { camera.rotation.y += rotationSpeed * delta; }
      if (keys['KeyD']) { camera.rotation.y -= rotationSpeed * delta; }
      let direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      direction.y = 0;
      direction.normalize();
      let moveX = 0, moveZ = 0;
      if (keys['KeyW']) {
        moveX += direction.x * moveSpeed * delta;
        moveZ += direction.z * moveSpeed * delta;
      }
      if (keys['KeyS']) {
        moveX -= direction.x * moveSpeed * delta;
        moveZ -= direction.z * moveSpeed * delta;
      }
      let newPos = camera.position.clone();
      newPos.x += moveX;
      newPos.z += moveZ;
      if (!isColliding(newPos, 1)) {
        camera.position.copy(newPos);
      }
    }

    /***********************
     * ミニマップ更新
     *  平原全体の境界、障害物、プレイヤー（青）、各敵（赤）を描画
     ***********************/
    function updateMinimap() {
      minimapCtx.clearRect(0, 0, minimap.width, minimap.height);
      let scale = minimap.width / terrainSize;
      // 平原境界
      minimapCtx.strokeStyle = '#fff';
      minimapCtx.strokeRect(0, 0, minimap.width, minimap.height);
      // 障害物描画
      minimapCtx.fillStyle = '#888';
      for (let i = 0; i < obstacles.length; i++) {
        let obs = obstacles[i];
        let x = (obs.position.x + terrainSize/2) * scale;
        let z = (obs.position.z + terrainSize/2) * scale;
        let w = obs.userData.width * scale;
        let d = obs.userData.depth * scale;
        minimapCtx.fillRect(x - w/2, minimap.height - (z + d/2), w, d);
      }
      // プレイヤー描画
      let playerX = (camera.position.x + terrainSize/2) * scale;
      let playerZ = (camera.position.z + terrainSize/2) * scale;
      minimapCtx.fillStyle = '#00f';
      minimapCtx.beginPath();
      minimapCtx.arc(playerX, minimap.height - playerZ, 5, 0, Math.PI * 2);
      minimapCtx.fill();
      // 各敵描画
      minimapCtx.fillStyle = '#f00';
      for (let i = 0; i < enemies.length; i++) {
        let enemy = enemies[i];
        let ex = (enemy.position.x + terrainSize/2) * scale;
        let ez = (enemy.position.z + terrainSize/2) * scale;
        minimapCtx.beginPath();
        minimapCtx.arc(ex, minimap.height - ez, 5, 0, Math.PI * 2);
        minimapCtx.fill();
      }
    }

    /***********************
     * アニメーションループ
     ***********************/
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      updatePlayer(delta);
      updateEnemies(delta);
      updateBullets(delta);
      updateMinimap();
      renderer.render(scene, camera);
    }

    window.onload = init;
  </script>
</body>
</html>
