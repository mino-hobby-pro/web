<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3D銃撃戦 vs CPU - Maze Shooter</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      z-index: 100;
    }
    #startButton {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 24px;
      cursor: pointer;
    }
    #instructions { font-size: 24px; text-align: center; }
  </style>
</head>
<body>
  <!-- タイトル画面（オーバーレイ） -->
  <div id="overlay">
    <div id="instructions">
      <h1>3D銃撃戦 vs CPU</h1>
      <p>迷宮に挑戦して、CPUを撃破せよ！</p>
      <p>操作：WASDキーで移動、マウスで視点操作、左クリックで射撃</p>
    </div>
    <button id="startButton">スタート</button>
  </div>

  <!-- Three.js ライブラリ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- PointerLockControls (Three.jsに付属のFPS操作用クラス) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/PointerLockControls.js"></script>

  <script>
    ////////////////////////////////////////////////////////////////////////////
    // グローバル変数宣言
    let scene, camera, renderer, clock;
    let controls;
    let maze, mazeWidth = 21, mazeHeight = 21, cellSize = 10;
    let wallMeshes = [];  // 衝突判定用に作成した壁オブジェクトを保存
    let enemy, enemySpeed = 3;
    let enemyPath = [];
    let enemyPathIndex = 0;
    let enemyRecalcTimer = 0;
    let bullets = [];
    const moveSpeed = 5;
    let keys = {KeyW: false, KeyA: false, KeyS: false, KeyD: false};

    ////////////////////////////////////////////////////////////////////////////
    // 迷宮生成（再帰的バックトラッキング法）
    function generateMaze(w, h) {
      // w・h は奇数である前提（外枠は壁）
      let maze = [];
      for (let i = 0; i < h; i++) {
        maze[i] = [];
        for (let j = 0; j < w; j++) {
          maze[i][j] = 1; // 1＝壁、0＝通路
        }
      }
      let stack = [];
      let startX = 1, startY = 1;
      maze[startY][startX] = 0;
      stack.push({x: startX, y: startY});
    
      while(stack.length > 0) {
        let current = stack[stack.length - 1];
        let x = current.x, y = current.y;
        let neighbours = [];
        let directions = [
          {dx: 2, dy: 0},
          {dx: -2, dy: 0},
          {dx: 0, dy: 2},
          {dx: 0, dy: -2}
        ];
        // シャッフル
        for (let i = directions.length - 1; i > 0; i--) {
          let j = Math.floor(Math.random() * (i + 1));
          [directions[i], directions[j]] = [directions[j], directions[i]];
        }
        directions.forEach(dir => {
          let nx = x + dir.dx, ny = y + dir.dy;
          if (ny > 0 && ny < h && nx > 0 && nx < w && maze[ny][nx] === 1) {
            neighbours.push({x: nx, y: ny, between: {x: x + dir.dx / 2, y: y + dir.dy / 2}});
          }
        });
        if (neighbours.length > 0) {
          let chosen = neighbours[Math.floor(Math.random() * neighbours.length)];
          maze[chosen.between.y][chosen.between.x] = 0;
          maze[chosen.y][chosen.x] = 0;
          stack.push({x: chosen.x, y: chosen.y});
        } else {
          stack.pop();
        }
      }
      return maze;
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // グリッド座標（迷宮セル） ⇔ ワールド座標（3D空間）の相互変換
    function gridToWorld(x, y) {
      return new THREE.Vector3(
        (x - mazeWidth / 2) * cellSize,
        0,
        (y - mazeHeight / 2) * cellSize
      );
    }
    function worldToGrid(position) {
      let gridX = Math.round(position.x / cellSize + mazeWidth / 2);
      let gridY = Math.round(position.z / cellSize + mazeHeight / 2);
      return { x: gridX, y: gridY };
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // 初期化処理：シーン、カメラ、レンダラー、コントロール、ライティング、床、迷宮、CPU生成
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
    
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
      camera.position.set(0, 5, 0);
    
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
    
      clock = new THREE.Clock();
    
      // PointerLockControls により FPS 操作を実現
      controls = new THREE.PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      
      // キーボード入力（WASD 操作）
      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('mousedown', onMouseDown);
    
      // 環境光＆方向光による照明
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      let dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(1, 10, 1);
      scene.add(dirLight);
    
      // 迷宮生成
      maze = generateMaze(mazeWidth, mazeHeight);
      createMaze();
    
      // 床（プレイヤーが歩く面）
      let floorGeometry = new THREE.PlaneGeometry(mazeWidth * cellSize, mazeHeight * cellSize);
      let floorMaterial = new THREE.MeshPhongMaterial({color: 0x444444});
      let floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);
    
      // CPU（敵）の生成：迷宮の右下付近に配置
      let enemyGridPos = { x: mazeWidth - 2, y: mazeHeight - 2 };
      let enemyWorldPos = gridToWorld(enemyGridPos.x, enemyGridPos.y);
      enemy = new THREE.Mesh(
        new THREE.BoxGeometry(4, 4, 4),
        new THREE.MeshPhongMaterial({color: 0xff0000})
      );
      enemy.position.set(enemyWorldPos.x, 2, enemyWorldPos.z);
      scene.add(enemy);
    
      // プレイヤーの開始位置は迷宮左上（セル座標 1,1）に設定
      let playerStart = gridToWorld(1, 1);
      controls.getObject().position.set(playerStart.x, 5, playerStart.z);
    
      window.addEventListener('resize', onWindowResize);
      animate();
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // 迷宮の壁を grid 情報から作成（各セルが 1 なら BoxGeometry）
    function createMaze() {
      let wallGeometry = new THREE.BoxGeometry(cellSize, 10, cellSize);
      let wallMaterial = new THREE.MeshPhongMaterial({color: 0x888888});
    
      for (let y = 0; y < mazeHeight; y++) {
        for (let x = 0; x < mazeWidth; x++) {
          if (maze[y][x] === 1) {
            let wall = new THREE.Mesh(wallGeometry, wallMaterial);
            let pos = gridToWorld(x, y);
            wall.position.set(pos.x, 5, pos.z);
            scene.add(wall);
            wallMeshes.push(wall);
          }
        }
      }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // リサイズ時の処理
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // キーボード入力イベント
    function onKeyDown(event) {
      if (keys[event.code] !== undefined) { keys[event.code] = true; }
    }
    function onKeyUp(event) {
      if (keys[event.code] !== undefined) { keys[event.code] = false; }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // マウスクリックで射撃（左クリック）
    function onMouseDown(event) {
      if (event.button === 0) shootBullet();
    }
    
    // 射撃機能：カメラ位置からマウスの向きに向けて小さな弾（黄色い球体）を発射
    function shootBullet() {
      let bulletGeometry = new THREE.SphereGeometry(0.5, 8, 8);
      let bulletMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
      let bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
      let startPos = new THREE.Vector3().copy(controls.getObject().position);
      bullet.position.copy(startPos);
  
      // カメラの向いている方向を取得して、そこへ発射
      let direction = new THREE.Vector3();
      controls.getDirection(direction).normalize();
      let bulletSpeed = 20;
      bullets.push({
        mesh: bullet,
        velocity: direction.multiplyScalar(bulletSpeed)
      });
      scene.add(bullet);
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // プレイヤー移動更新（WASD 利用＋簡易衝突判定）
    function updatePlayer(delta) {
      let moveDirection = new THREE.Vector3();
      let forward = new THREE.Vector3();
      let right = new THREE.Vector3();
  
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
  
      if (keys["KeyW"]) moveDirection.add(forward);
      if (keys["KeyS"]) moveDirection.sub(forward);
      if (keys["KeyA"]) moveDirection.sub(right);
      if (keys["KeyD"]) moveDirection.add(right);
  
      moveDirection.normalize();
      let displacement = moveDirection.multiplyScalar(moveSpeed * delta);
      // 衝突判定：新しい位置で壁と重なっていなければ移動
      if (!checkCollision(controls.getObject().position, displacement)) {
        controls.getObject().position.add(displacement);
      }
    }
    
    // 衝突判定（プレイヤーの新位置を仮想球体とし、各壁のバウンディングボックスと比較）
    function checkCollision(position, displacement) {
      let newPos = new THREE.Vector3().copy(position).add(displacement);
      let playerSphere = new THREE.Sphere(newPos, 2);
      for (let i = 0; i < wallMeshes.length; i++) {
        let box = new THREE.Box3().setFromObject(wallMeshes[i]);
        if (box.intersectsSphere(playerSphere)) return true;
      }
      return false;
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // A*アルゴリズムによる経路探索（グリッド上の経路を求める）
    function astar(start, goal, maze) {
      let openSet = [];
      let cameFrom = {};
      let gScore = {};
      let fScore = {};
    
      function key(node) { return node.x + "," + node.y; }
      function heuristic(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }
    
      openSet.push(start);
      gScore[key(start)] = 0;
      fScore[key(start)] = heuristic(start, goal);
    
      while (openSet.length > 0) {
        // 現在のノード：fScore の最小値を持つノードを選択
        let current = openSet.reduce((prev, curr) => {
          return fScore[key(curr)] < fScore[key(prev)] ? curr : prev;
        });
    
        if (current.x === goal.x && current.y === goal.y) {
          // 経路を再構築
          let path = [];
          let curKey = key(current);
          while (cameFrom[curKey] !== undefined) {
            path.push(current);
            current = cameFrom[curKey];
            curKey = key(current);
          }
          path.push(start);
          path.reverse();
          return path;
        }
    
        openSet = openSet.filter(n => n.x !== current.x || n.y !== current.y);
    
        let neighbors = [];
        let directions = [
          {x: 1, y: 0},
          {x: -1, y: 0},
          {x: 0, y: 1},
          {x: 0, y: -1}
        ];
        directions.forEach(dir => {
          let neighbor = {x: current.x + dir.x, y: current.y + dir.y};
          if (neighbor.x >= 0 && neighbor.x < mazeWidth &&
              neighbor.y >= 0 && neighbor.y < mazeHeight &&
              maze[neighbor.y][neighbor.x] === 0) {
            neighbors.push(neighbor);
          }
        });
    
        neighbors.forEach(neighbor => {
          let tentative_gScore = gScore[key(current)] + 1;
          if (tentative_gScore < (gScore[key(neighbor)] || Infinity)) {
            cameFrom[key(neighbor)] = current;
            gScore[key(neighbor)] = tentative_gScore;
            fScore[key(neighbor)] = tentative_gScore + heuristic(neighbor, goal);
            if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
              openSet.push(neighbor);
            }
          }
        });
      }
      return [];  // 経路が見つからなかった場合
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // CPU（敵）の移動更新：1秒ごとに A* 経路を再計算し、得られたノード順に移動
    function updateEnemy(delta) {
      enemyRecalcTimer += delta;
      if (enemyRecalcTimer > 1) { // 1秒ごとに経路探索
        enemyRecalcTimer = 0;
        let enemyGrid = worldToGrid(enemy.position);
        let playerGrid = worldToGrid(controls.getObject().position);
        enemyPath = astar({x: enemyGrid.x, y: enemyGrid.y}, {x: playerGrid.x, y: playerGrid.y}, maze);
        enemyPathIndex = 0;
      }
    
      if (enemyPath && enemyPath.length > 0 && enemyPathIndex < enemyPath.length) {
        let targetCell = enemyPath[enemyPathIndex];
        let targetPos = gridToWorld(targetCell.x, targetCell.y);
        targetPos.y = enemy.position.y; // 高さは一定
        let direction = new THREE.Vector3().subVectors(targetPos, enemy.position);
        let distance = direction.length();
        if (distance < 0.5) {
          enemyPathIndex++;
        } else {
          direction.normalize();
          enemy.position.add(direction.multiplyScalar(enemySpeed * delta));
        }
      }
      
      // プレイヤーとの接近判定（一定距離に入ったらゲームオーバー）
      let distanceToPlayer = enemy.position.distanceTo(controls.getObject().position);
      if(distanceToPlayer < 3){
        alert("ゲームオーバー！CPUに捕まった！");
        window.location.reload();
      }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // 弾の更新処理：各フレームで発射弾を移動・衝突判定
    function updateBullets(delta) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        let bulletData = bullets[i];
        bulletData.mesh.position.add(bulletData.velocity.clone().multiplyScalar(delta));
        // 範囲外なら削除
        if (bulletData.mesh.position.length() > 500) {
          scene.remove(bulletData.mesh);
          bullets.splice(i, 1);
          continue;
        }
        // 敵との衝突判定（単純な距離判定）
        if (bulletData.mesh.position.distanceTo(enemy.position) < 3) {
          scene.remove(enemy);
          enemy = null;
          scene.remove(bulletData.mesh);
          bullets.splice(i, 1);
          console.log("Enemy eliminated!");
          // 必要に応じて、ここで新たな敵の出現やゲームクリア処理を追加可能
        }
      }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // メインアニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      let delta = clock.getDelta();
      updatePlayer(delta);
      if (enemy) updateEnemy(delta);
      updateBullets(delta);
      renderer.render(scene, camera);
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // 「スタート」ボタン押下でオーバーレイを非表示にし、ポインター・ロックを開始、初期化
    document.getElementById('startButton').addEventListener('click', function() {
      document.getElementById('overlay').style.display = 'none';
      controls.lock();
      init();
    });
  </script>
</body>
</html>
