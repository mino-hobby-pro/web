<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3D Shooter vs CPU - Expanded Stage</title>
  <style>
    body { margin: 0; overflow: hidden; }
    /* タイトルオーバーレイ */
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-family: sans-serif;
      z-index: 2;
    }
    /* ゲームオーバー表示 */
    #game-over {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #ff5555;
      font-family: sans-serif;
      font-size: 50px;
      z-index: 3;
      visibility: hidden;
    }
    /* ミニマップ：画面左上に固定　※31セル×10px=310px */
    #minimap {
      position: absolute;
      top: 10px;
      left: 10px;
      border: 2px solid #fff;
      background: rgba(0, 0, 0, 0.5);
      z-index: 4;
    }
  </style>
</head>
<body>
  <!-- タイトルオーバーレイ -->
  <div id="overlay">
    <h1>3D Shooter vs CPU</h1>
    <p>【操作方法】</p>
    <p>W　：前進</p>
    <p>S　：後退</p>
    <p>A　：左回転</p>
    <p>D　：右回転</p>
    <p>Space：射撃</p>
    <p>Enter：ゲーム開始</p>
  </div>
  <!-- ゲームオーバー表示 -->
  <div id="game-over">
    <h1>GAME OVER</h1>
    <p>ページを再読み込みして再挑戦してください！</p>
  </div>
  <!-- ミニマップ用キャンバス（31セル×10px = 310px） -->
  <canvas id="minimap" width="310" height="310"></canvas>
  
  <!-- Three.js の CDN (r128) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // グローバル変数
    let scene, camera, renderer, clock;
    let maze, walls = [];
    const cellSize = 10;            // 1セルのサイズ
    // マップを拡張：31×31セル（奇数推奨）
    const mazeWidth = 31, mazeHeight = 31;
    let keys = {};                  // キー押下状態
    let bullets = [];               // プレイヤーの弾
    let enemyBullets = [];          // CPUの弾
    let lastShootTime = 0;          // 射撃クールダウン管理
    const shootCooldown = 0.3;
    let enemyShootTimer = 0;
    let playerAlive = true, enemyAlive = true;
    let playerHealth = 100, enemyHealth = 100;
    let enemy;                    // CPU（敵）オブジェクト

    // ミニマップ用変数
    let minimap, minimapCtx;
    
    // 初期化
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.y = 2;  // プレイヤーの目線

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      clock = new THREE.Clock();

      // ミニマップ用キャンバス取得
      minimap = document.getElementById('minimap');
      minimapCtx = minimap.getContext('2d');

      // ライティング：環境光と方向光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 0);
      scene.add(directionalLight);

      // 迷路生成と壁配置
      maze = generateMaze(mazeWidth, mazeHeight);
      createMaze();

      // 床の作成
      const floorGeometry = new THREE.PlaneGeometry(mazeWidth*cellSize, mazeHeight*cellSize);
      const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);

      // プレイヤー初期位置：迷路入口（セル (1,1)）に配置
      const offsetX = - (mazeWidth * cellSize) / 2;
      const offsetZ = - (mazeHeight * cellSize) / 2;
      let startX = cellSize * 1;
      let startZ = cellSize * 1;
      camera.position.set(startX + offsetX + cellSize/2, 2, startZ + offsetZ + cellSize/2);

      // CPU（敵）の作成：グループ化したボディ＋ヘッドによるモデル
      createEnemy();

      // キーボードイベント登録
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
      window.addEventListener('keydown', onShoot);
      window.addEventListener('resize', onWindowResize, false);

      animate();
    }

    // ウィンドウリサイズ対応
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // キー押下・離し処理
    function onKeyDown(e) {
      keys[e.code] = true;
      // タイトルオーバーレイ表示中にEnterキーでゲーム開始
      if (document.getElementById('overlay').style.display !== 'none' && e.code === 'Enter') {
        document.getElementById('overlay').style.display = 'none';
      }
    }
    function onKeyUp(e) {
      keys[e.code] = false;
    }
    // 射撃処理（Spaceキー）
    function onShoot(e) {
      if (!playerAlive) return;
      if (e.code === 'Space') {
        const currentTime = clock.getElapsedTime();
        if (currentTime - lastShootTime > shootCooldown) {
          shootBullet();
          lastShootTime = currentTime;
        }
      }
    }
    // プレイヤー弾の生成
    function shootBullet() {
      const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
      const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
      bullet.position.copy(camera.position);
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      bullet.userData = { velocity: direction.multiplyScalar(50) }; // 発射速度
      scene.add(bullet);
      bullets.push(bullet);
    }
    // CPUの射撃（プレイヤー方向に発射）
    function enemyShoot() {
      if (!enemyAlive) return;
      const bulletGeometry = new THREE.SphereGeometry(0.3, 8, 8);
      const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
      bullet.position.copy(enemy.position);
      const direction = new THREE.Vector3();
      direction.subVectors(camera.position, enemy.position).normalize();
      bullet.userData = { velocity: direction.multiplyScalar(30) };
      scene.add(bullet);
      enemyBullets.push(bullet);
    }

    // 迷路生成（再帰的バックトラッキングアルゴリズム）
    function generateMaze(w, h) {
      let maze = [];
      for (let y = 0; y < h; y++) {
        maze[y] = [];
        for (let x = 0; x < w; x++) {
          maze[y][x] = 1;
        }
      }
      // 配列シャッフル用関数
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      // 再帰関数で通路を掘る
      function carve(x, y) {
        maze[y][x] = 0;
        let directions = [ [2,0], [-2,0], [0,2], [0,-2] ];
        shuffle(directions);
        for (let i = 0; i < directions.length; i++) {
          let nx = x + directions[i][0];
          let ny = y + directions[i][1];
          if (ny > 0 && ny < h - 1 && nx > 0 && nx < w - 1) {
            if (maze[ny][nx] === 1) {
              maze[y + directions[i][1] / 2][x + directions[i][0] / 2] = 0;
              carve(nx, ny);
            }
          }
        }
      }
      carve(1, 1);
      return maze;
    }
    // 迷路上に壁を配置する
    function createMaze() {
      const offsetX = - (mazeWidth * cellSize) / 2;
      const offsetZ = - (mazeHeight * cellSize) / 2;
      const wallGeometry = new THREE.BoxGeometry(cellSize, 10, cellSize);
      const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      for (let y = 0; y < mazeHeight; y++) {
        for (let x = 0; x < mazeWidth; x++) {
          if (maze[y][x] === 1) {
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x * cellSize + offsetX + cellSize/2, 5, y * cellSize + offsetZ + cellSize/2);
            scene.add(wall);
            walls.push(wall);
          }
        }
      }
    }
    // 簡易衝突判定（水平面のみでチェック）
    function isColliding(pos, radius) {
      for (let i = 0; i < walls.length; i++) {
        const wall = walls[i];
        const wallPos = wall.position;
        if (Math.abs(pos.x - wallPos.x) < cellSize/2 + radius &&
            Math.abs(pos.z - wallPos.z) < cellSize/2 + radius) {
          return true;
        }
      }
      return false;
    }
    // 弾の更新処理（プレイヤー弾・敵弾共通）
    function updateBullets(delta) {
      // プレイヤーの弾
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
        if (b.position.length() > mazeWidth * cellSize) {
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        if (isColliding(b.position, 0.3)) {
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        // 敵（CPU）との命中判定：中心から距離2未満ならヒット
        if (enemyAlive && b.position.distanceTo(enemy.position) < 2) {
          enemyHealth -= 50;
          scene.remove(b);
          bullets.splice(i, 1);
          if (enemyHealth <= 0) {
            scene.remove(enemy);
            enemyAlive = false;
          }
          continue;
        }
      }
      // 敵（CPU）の弾
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
        if (b.position.length() > mazeWidth * cellSize) {
          scene.remove(b);
          enemyBullets.splice(i, 1);
          continue;
        }
        if (isColliding(b.position, 0.3)) {
          scene.remove(b);
          enemyBullets.splice(i, 1);
          continue;
        }
        // プレイヤーへのヒット判定（距離1.5未満）
        if (b.position.distanceTo(camera.position) < 1.5) {
          playerHealth -= 50;
          scene.remove(b);
          enemyBullets.splice(i, 1);
          if (playerHealth <= 0) {
            playerAlive = false;
            showGameOver();
          }
          continue;
        }
      }
    }
    // ゲームオーバー表示
    function showGameOver() {
      document.getElementById('game-over').style.visibility = "visible";
    }
    // プレイヤー更新（移動と回転：W/S と A/D キー）
    function updatePlayer(delta) {
      if (!playerAlive) return;
      const moveSpeed = 20;           // 移動速度
      const rotationSpeed = Math.PI;  // 回転速度（ラジアン/秒）
      if (keys['KeyA']) { camera.rotation.y += rotationSpeed * delta; }
      if (keys['KeyD']) { camera.rotation.y -= rotationSpeed * delta; }
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      direction.y = 0; direction.normalize();
      let moveX = 0, moveZ = 0;
      if (keys['KeyW']) {
        moveX += direction.x * moveSpeed * delta;
        moveZ += direction.z * moveSpeed * delta;
      }
      if (keys['KeyS']) {
        moveX -= direction.x * moveSpeed * delta;
        moveZ -= direction.z * moveSpeed * delta;
      }
      const newPos = camera.position.clone();
      newPos.x += moveX;
      newPos.z += moveZ;
      if (!isColliding(newPos, 1)) {
        camera.position.x = newPos.x;
        camera.position.z = newPos.z;
      }
    }
    // CPU（敵）の作成：ボディとヘッドのパーツをグループ化
    function createEnemy() {
      enemy = new THREE.Group();
      // ボディ
      const bodyGeometry = new THREE.BoxGeometry(1.5, 3, 1);
      const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
      bodyMesh.position.y = 1.5;
      // ヘッド
      const headGeometry = new THREE.SphereGeometry(0.75, 16, 16);
      const headMaterial = new THREE.MeshPhongMaterial({ color: 0xff8888 });
      const headMesh = new THREE.Mesh(headGeometry, headMaterial);
      headMesh.position.y = 3.0;
      enemy.add(bodyMesh);
      enemy.add(headMesh);
      // 初期の速度ベクトル（初回はゼロ）
      enemy.userData.velocity = new THREE.Vector3(0, 0, 0);
      
      // 迷路の反対側（セル (mazeWidth-2, mazeHeight-2)）に配置
      const offsetX = - (mazeWidth * cellSize) / 2;
      const offsetZ = - (mazeHeight * cellSize) / 2;
      let enemyX = cellSize * (mazeWidth - 2);
      let enemyZ = cellSize * (mazeHeight - 2);
      enemy.position.set(enemyX + offsetX + cellSize/2, 0, enemyZ + offsetZ + cellSize/2);
      scene.add(enemy);
    }
    // CPU（敵）のアップデート：目的（プレイヤー）に向かいつつ、周囲の壁回避処理を追加
    function updateEnemy(delta) {
      if (!enemyAlive) return;
      
      // プレイヤー方向への単純なベクトルを計算
      let desired = new THREE.Vector3();
      desired.subVectors(camera.position, enemy.position);
      desired.y = 0;
      let distance = desired.length();
      if (distance < 0.1) distance = 0.1;  // ゼロ除算回避
      desired.normalize();

      // パラメータ：最大速度、加速度
      const enemyMaxSpeed = 8;
      const enemyAcceleration = 20;

      // 目標ベクトルから理想の速度（desiredVelocity）を算出
      const desiredVelocity = desired.clone().multiplyScalar(enemyMaxSpeed);

      // 現在の速度（enemy.userData.velocity）がなければ初期化
      let currentVelocity = enemy.userData.velocity;
      if (!currentVelocity) {
        enemy.userData.velocity = new THREE.Vector3();
        currentVelocity = enemy.userData.velocity;
      }

      // 加速度分だけ現在の速度を更新（シンプルなスティアリング）
      let deltaV = desiredVelocity.clone().sub(currentVelocity);
      let maxDelta = enemyAcceleration * delta;
      if (deltaV.length() > maxDelta) {
        deltaV.setLength(maxDelta);
      }
      currentVelocity.add(deltaV);

      // まずは現在の速度方向に沿った新しい位置を仮算出
      let tentativePos = enemy.position.clone().add(currentVelocity.clone().multiplyScalar(delta));
      if (!isColliding(tentativePos, 1)) {
        enemy.position.copy(tentativePos);
      } else {
        // 衝突が予測される場合、左右に角度を変えて代替経路を探す
        let found = false;
        let angles = [0.3, -0.3, 0.6, -0.6, 0.9, -0.9];
        for (let a of angles) {
          let testDir = desired.clone().applyAxisAngle(new THREE.Vector3(0,1,0), a);
          let testVelocity = testDir.clone().multiplyScalar(enemyMaxSpeed);
          let testPos = enemy.position.clone().add(testVelocity.clone().multiplyScalar(delta));
          if (!isColliding(testPos, 1)) {
            enemy.userData.velocity.copy(testVelocity);
            enemy.position.copy(testPos);
            found = true;
            break;
          }
        }
        if (!found) {
          // 代替案が見つからなければ、徐々にスローダウン
          enemy.userData.velocity.multiplyScalar(0.5);
        }
      }
      
      // 速度に合わせて向きを調整する（移動している方向へ向ける）
      if (enemy.userData.velocity.length() > 0.1) {
        enemy.rotation.y = Math.atan2(enemy.userData.velocity.x, enemy.userData.velocity.z);
      }
      
      // CPUは約2秒ごとに射撃
      enemyShootTimer += delta;
      if (enemyShootTimer > 2) {
        enemyShoot();
        enemyShootTimer = 0;
      }
    }

    // ミニマップ更新：迷路全体、プレイヤーとCPUの現在位置を描画
    function updateMinimap() {
      minimapCtx.clearRect(0, 0, minimap.width, minimap.height);
      let cellPixelSize = minimap.width / mazeWidth; // 例: 310/31 = 10px
      // 迷路描画：壁はグレー、通路は暗い背景
      for (let y = 0; y < mazeHeight; y++) {
        for (let x = 0; x < mazeWidth; x++) {
          minimapCtx.fillStyle = maze[y][x] === 1 ? '#555' : '#222';
          minimapCtx.fillRect(x * cellPixelSize, y * cellPixelSize, cellPixelSize, cellPixelSize);
        }
      }
      // ワールド座標→グリッド座標（迷路の原点：offset, セルサイズを利用）
      const offsetX = - (mazeWidth * cellSize) / 2;
      const offsetZ = - (mazeHeight * cellSize) / 2;
      // プレイヤー位置描画（青い円）
      let playerGridX = Math.floor((camera.position.x - offsetX) / cellSize);
      let playerGridY = Math.floor((camera.position.z - offsetZ) / cellSize);
      minimapCtx.fillStyle = '#00f';
      minimapCtx.beginPath();
      minimapCtx.arc(playerGridX * cellPixelSize + cellPixelSize/2, playerGridY * cellPixelSize + cellPixelSize/2, cellPixelSize/3, 0, Math.PI*2);
      minimapCtx.fill();
      // CPU（敵）位置描画（赤い円）
      if (enemyAlive) {
        let enemyGridX = Math.floor((enemy.position.x - offsetX) / cellSize);
        let enemyGridY = Math.floor((enemy.position.z - offsetZ) / cellSize);
        minimapCtx.fillStyle = '#f00';
        minimapCtx.beginPath();
        minimapCtx.arc(enemyGridX * cellPixelSize + cellPixelSize/2, enemyGridY * cellPixelSize + cellPixelSize/2, cellPixelSize/3, 0, Math.PI * 2);
        minimapCtx.fill();
      }
    }

    // アニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      updatePlayer(delta);
      updateEnemy(delta);
      updateBullets(delta);
      updateMinimap();
      renderer.render(scene, camera);
    }

    window.onload = init;
  </script>
</body>
</html>
